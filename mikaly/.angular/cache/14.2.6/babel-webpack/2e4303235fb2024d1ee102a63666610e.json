{"ast":null,"code":"/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} items - Specific items to append to the end of an array\n * @return {?}\n */\nfunction append(items) {\n  return (\n    /**\n    * @param {?} existing\n    * @return {?}\n    */\n    function appendOperator(existing) {\n      // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n      // just return `existing`\n\n      /** @type {?} */\n      const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n\n      if (itemsNotProvidedButExistingIs) {\n        return (\n          /** @type {?} */\n          existing\n        );\n      }\n\n      if (Array.isArray(existing)) {\n        return existing.concat(\n        /** @type {?} */\n        items);\n      } // For example if some property is added dynamically\n      // and didn't exist before thus it's not `ArrayLike`\n\n\n      return (\n        /** @type {?} */\n        items\n      );\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {...?} operators\n * @return {?}\n */\n\n\nfunction compose(...operators) {\n  return (\n    /**\n    * @param {?} existing\n    * @return {?}\n    */\n    function composeOperator(existing) {\n      return operators.reduce(\n      /**\n      * @param {?} accumulator\n      * @param {?} operator\n      * @return {?}\n      */\n      (accumulator, operator) => operator(accumulator), existing);\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isStateOperator(value) {\n  return typeof value === 'function';\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isPredicate(value) {\n  return typeof value === 'function';\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n/**\n * @param {?} index\n * @return {?}\n */\n\n\nfunction invalidIndex(index) {\n  return Number.isNaN(index) || index === -1;\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isNil(value) {\n  return value === null || isUndefined(value);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} operatorOrValue\n * @param {?=} existing\n * @return {?}\n */\n\n\nfunction retrieveValue(operatorOrValue, existing) {\n  // If state operator is a function\n  // then call it with an original value\n  if (isStateOperator(operatorOrValue)) {\n    /** @type {?} */\n    const value = operatorOrValue(\n    /** @type {?} */\n\n    /** @type {?} */\n    existing);\n    return (\n      /** @type {?} */\n      value\n    );\n  } // If operator or value was not provided\n  // e.g. `elseOperatorOrValue` is `undefined`\n  // then we just return an original value\n\n\n  if (isUndefined(operatorOrValue)) {\n    return (\n      /** @type {?} */\n\n      /** @type {?} */\n\n      /** @type {?} */\n      existing\n    );\n  }\n\n  return (\n    /** @type {?} */\n    operatorOrValue\n  );\n}\n/**\n * @template T\n * @param {?} condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param {?} trueOperatorOrValue - Any value or a state operator\n * @param {?=} elseOperatorOrValue - Any value or a state operator\n * @return {?}\n */\n\n\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\n  return (\n    /**\n    * @param {?} existing\n    * @return {?}\n    */\n    function iifOperator(existing) {\n      // Convert the value to a boolean\n\n      /** @type {?} */\n      let result = !!condition; // but if it is a function then run it to get the result\n\n      if (isPredicate(condition)) {\n        result = condition(existing);\n      }\n\n      if (result) {\n        return retrieveValue(trueOperatorOrValue,\n        /** @type {?} */\n        existing);\n      }\n\n      return retrieveValue(\n      /** @type {?} */\n      elseOperatorOrValue,\n      /** @type {?} */\n      existing);\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} value - Value to insert\n * @param {?=} beforePosition\n * @return {?}\n */\n\n\nfunction insertItem(value, beforePosition) {\n  return (\n    /**\n    * @param {?} existing\n    * @return {?}\n    */\n    function insertItemOperator(existing) {\n      // Have to check explicitly for `null` and `undefined`\n      // because `value` can be `0`, thus `!value` will return `true`\n      if (isNil(value) && existing) {\n        return (\n          /** @type {?} */\n          existing\n        );\n      } // Property may be dynamic and might not existed before\n\n\n      if (!Array.isArray(existing)) {\n        return [\n        /** @type {?} */\n        value];\n      }\n      /** @type {?} */\n\n\n      const clone = existing.slice();\n      /** @type {?} */\n\n      let index = 0; // No need to call `isNumber`\n      // as we are checking `> 0` not `>= 0`\n      // everything except number will return false here\n\n      if (\n      /** @type {?} */\n      beforePosition > 0) {\n        index =\n        /** @type {?} */\n        beforePosition;\n      }\n\n      clone.splice(index, 0,\n      /** @type {?} */\n      value);\n      return clone;\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} patchObject\n * @return {?}\n */\n\n\nfunction patch(patchObject) {\n  return (\n    /**\n    * @template U\n    * @param {?} existing\n    * @return {?}\n    */\n    function patchStateOperator(existing) {\n      /** @type {?} */\n      let clone = null;\n\n      for (const k in patchObject) {\n        /** @type {?} */\n        const newValue = patchObject[k];\n        /** @type {?} */\n\n        const existingPropValue = existing[k];\n        /** @type {?} */\n\n        const newPropValue = isStateOperator(newValue) ? newValue(\n        /** @type {?} */\n        existingPropValue) : newValue;\n\n        if (newPropValue !== existingPropValue) {\n          if (!clone) {\n            clone = Object.assign({},\n            /** @type {?} */\n            existing);\n          }\n\n          clone[k] = newPropValue;\n        }\n      }\n\n      return clone || existing;\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param {?} operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n * @return {?}\n */\n\n\nfunction updateItem(selector, operatorOrValue) {\n  return (\n    /**\n    * @param {?} existing\n    * @return {?}\n    */\n    function updateItemOperator(existing) {\n      /** @type {?} */\n      let index = -1;\n\n      if (isPredicate(selector)) {\n        index = existing.findIndex(selector);\n      } else if (isNumber(selector)) {\n        index = selector;\n      }\n\n      if (invalidIndex(index)) {\n        return (\n          /** @type {?} */\n          existing\n        );\n      }\n      /** @type {?} */\n\n\n      let value =\n      /** @type {?} */\n      null; // Need to check if the new item value will change the existing item value\n      // then, only if it will change it then clone the array and set the item\n\n      if (isStateOperator(operatorOrValue)) {\n        value = operatorOrValue(\n        /** @type {?} */\n        existing[index]);\n      } else {\n        value = operatorOrValue;\n      } // If the value hasn't been mutated\n      // then we just return `existing` array\n\n\n      if (value === existing[index]) {\n        return (\n          /** @type {?} */\n          existing\n        );\n      }\n      /** @type {?} */\n\n\n      const clone = existing.slice();\n      clone[index] =\n      /** @type {?} */\n      value;\n      return clone;\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} selector - index or predicate to remove an item from an array by\n * @return {?}\n */\n\n\nfunction removeItem(selector) {\n  return (\n    /**\n    * @param {?} existing\n    * @return {?}\n    */\n    function removeItemOperator(existing) {\n      /** @type {?} */\n      let index = -1;\n\n      if (isPredicate(selector)) {\n        index = existing.findIndex(selector);\n      } else if (isNumber(selector)) {\n        index = selector;\n      }\n\n      if (invalidIndex(index)) {\n        return (\n          /** @type {?} */\n          existing\n        );\n      }\n      /** @type {?} */\n\n\n      const clone = existing.slice();\n      clone.splice(index, 1);\n      return clone;\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { append, compose, iif, insertItem, isStateOperator, patch, removeItem, updateItem };","map":{"version":3,"names":["append","items","appendOperator","existing","itemsNotProvidedButExistingIs","length","Array","isArray","concat","compose","operators","composeOperator","reduce","accumulator","operator","isStateOperator","value","isUndefined","isPredicate","isNumber","invalidIndex","index","Number","isNaN","isNil","retrieveValue","operatorOrValue","iif","condition","trueOperatorOrValue","elseOperatorOrValue","iifOperator","result","insertItem","beforePosition","insertItemOperator","clone","slice","splice","patch","patchObject","patchStateOperator","k","newValue","existingPropValue","newPropValue","Object","assign","updateItem","selector","updateItemOperator","findIndex","removeItem","removeItemOperator"],"sources":["C:/Users/jogas/OneDrive/Bureau/mikaly/mikaly/node_modules/@ngxs/store/__ivy_ngcc__/fesm2015/ngxs-store-operators.js"],"sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} items - Specific items to append to the end of an array\n * @return {?}\n */\nfunction append(items) {\n    return (/**\n     * @param {?} existing\n     * @return {?}\n     */\n    function appendOperator(existing) {\n        // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n        // just return `existing`\n        /** @type {?} */\n        const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n        if (itemsNotProvidedButExistingIs) {\n            return (/** @type {?} */ (existing));\n        }\n        if (Array.isArray(existing)) {\n            return existing.concat((/** @type {?} */ (items)));\n        }\n        // For example if some property is added dynamically\n        // and didn't exist before thus it's not `ArrayLike`\n        return (/** @type {?} */ (items));\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {...?} operators\n * @return {?}\n */\nfunction compose(...operators) {\n    return (/**\n     * @param {?} existing\n     * @return {?}\n     */\n    function composeOperator(existing) {\n        return operators.reduce((/**\n         * @param {?} accumulator\n         * @param {?} operator\n         * @return {?}\n         */\n        (accumulator, operator) => operator(accumulator)), existing);\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction isStateOperator(value) {\n    return typeof value === 'function';\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction isPredicate(value) {\n    return typeof value === 'function';\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n/**\n * @param {?} index\n * @return {?}\n */\nfunction invalidIndex(index) {\n    return Number.isNaN(index) || index === -1;\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction isNil(value) {\n    return value === null || isUndefined(value);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} operatorOrValue\n * @param {?=} existing\n * @return {?}\n */\nfunction retrieveValue(operatorOrValue, existing) {\n    // If state operator is a function\n    // then call it with an original value\n    if (isStateOperator(operatorOrValue)) {\n        /** @type {?} */\n        const value = operatorOrValue((/** @type {?} */ ((/** @type {?} */ (existing)))));\n        return (/** @type {?} */ (value));\n    }\n    // If operator or value was not provided\n    // e.g. `elseOperatorOrValue` is `undefined`\n    // then we just return an original value\n    if (isUndefined(operatorOrValue)) {\n        return (/** @type {?} */ ((/** @type {?} */ (((/** @type {?} */ (existing)))))));\n    }\n    return (/** @type {?} */ (operatorOrValue));\n}\n/**\n * @template T\n * @param {?} condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param {?} trueOperatorOrValue - Any value or a state operator\n * @param {?=} elseOperatorOrValue - Any value or a state operator\n * @return {?}\n */\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\n    return (/**\n     * @param {?} existing\n     * @return {?}\n     */\n    function iifOperator(existing) {\n        // Convert the value to a boolean\n        /** @type {?} */\n        let result = !!condition;\n        // but if it is a function then run it to get the result\n        if (isPredicate(condition)) {\n            result = condition(existing);\n        }\n        if (result) {\n            return retrieveValue(trueOperatorOrValue, (/** @type {?} */ (existing)));\n        }\n        return retrieveValue((/** @type {?} */ (elseOperatorOrValue)), (/** @type {?} */ (existing)));\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} value - Value to insert\n * @param {?=} beforePosition\n * @return {?}\n */\nfunction insertItem(value, beforePosition) {\n    return (/**\n     * @param {?} existing\n     * @return {?}\n     */\n    function insertItemOperator(existing) {\n        // Have to check explicitly for `null` and `undefined`\n        // because `value` can be `0`, thus `!value` will return `true`\n        if (isNil(value) && existing) {\n            return (/** @type {?} */ (existing));\n        }\n        // Property may be dynamic and might not existed before\n        if (!Array.isArray(existing)) {\n            return [(/** @type {?} */ (value))];\n        }\n        /** @type {?} */\n        const clone = existing.slice();\n        /** @type {?} */\n        let index = 0;\n        // No need to call `isNumber`\n        // as we are checking `> 0` not `>= 0`\n        // everything except number will return false here\n        if ((/** @type {?} */ (beforePosition)) > 0) {\n            index = (/** @type {?} */ (beforePosition));\n        }\n        clone.splice(index, 0, (/** @type {?} */ (value)));\n        return clone;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} patchObject\n * @return {?}\n */\nfunction patch(patchObject) {\n    return (/**\n     * @template U\n     * @param {?} existing\n     * @return {?}\n     */\n    function patchStateOperator(existing) {\n        /** @type {?} */\n        let clone = null;\n        for (const k in patchObject) {\n            /** @type {?} */\n            const newValue = patchObject[k];\n            /** @type {?} */\n            const existingPropValue = existing[k];\n            /** @type {?} */\n            const newPropValue = isStateOperator(newValue)\n                ? newValue((/** @type {?} */ (existingPropValue)))\n                : newValue;\n            if (newPropValue !== existingPropValue) {\n                if (!clone) {\n                    clone = Object.assign({}, ((/** @type {?} */ (existing))));\n                }\n                clone[k] = newPropValue;\n            }\n        }\n        return clone || existing;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param {?} operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n * @return {?}\n */\nfunction updateItem(selector, operatorOrValue) {\n    return (/**\n     * @param {?} existing\n     * @return {?}\n     */\n    function updateItemOperator(existing) {\n        /** @type {?} */\n        let index = -1;\n        if (isPredicate(selector)) {\n            index = existing.findIndex(selector);\n        }\n        else if (isNumber(selector)) {\n            index = selector;\n        }\n        if (invalidIndex(index)) {\n            return (/** @type {?} */ (existing));\n        }\n        /** @type {?} */\n        let value = (/** @type {?} */ (null));\n        // Need to check if the new item value will change the existing item value\n        // then, only if it will change it then clone the array and set the item\n        if (isStateOperator(operatorOrValue)) {\n            value = operatorOrValue((/** @type {?} */ (existing[index])));\n        }\n        else {\n            value = operatorOrValue;\n        }\n        // If the value hasn't been mutated\n        // then we just return `existing` array\n        if (value === existing[index]) {\n            return (/** @type {?} */ (existing));\n        }\n        /** @type {?} */\n        const clone = existing.slice();\n        clone[index] = (/** @type {?} */ (value));\n        return clone;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} selector - index or predicate to remove an item from an array by\n * @return {?}\n */\nfunction removeItem(selector) {\n    return (/**\n     * @param {?} existing\n     * @return {?}\n     */\n    function removeItemOperator(existing) {\n        /** @type {?} */\n        let index = -1;\n        if (isPredicate(selector)) {\n            index = existing.findIndex(selector);\n        }\n        else if (isNumber(selector)) {\n            index = selector;\n        }\n        if (invalidIndex(index)) {\n            return (/** @type {?} */ (existing));\n        }\n        /** @type {?} */\n        const clone = existing.slice();\n        clone.splice(index, 1);\n        return clone;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { append, compose, iif, insertItem, isStateOperator, patch, removeItem, updateItem };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}